<a name="readme-top"></a>
<!-- PROJECT SHIELDS -->
[![Contributors][contributors-shield]]()
[![MIT License][license-shield]][license-url]
[![LinkedIn][linkedin-shield]][linkedin-url]

<!-- PROJECT Name --> 
<h1 align="center">Design an asynchronous FIFO to safely pass data from one clock domain to another asynchronous clock domain</h1>

<!-- Block Diagram -->
## Block Diagram
* Using a FIFO to pass data from one clock domain to another clock domain requires multi-asynchronous clock design techniques.
* One method that is used to design, synthesize and analyze a safe FIFO between different clock domains using Gray code pointers that are synchronized into a different clock domain before testing for "FIFO full" or "FIFO empty" conditions.
* An asynchronous FIFO refers to a FIFO design where data values are written to a FIFO buffer from one clock domain and the data values are read from the same FIFO buffer from another clock domain, where the two clock domains are asynchronous to each other.
* Asynchronous FIFO design requires careful attention to details from pointer generation techniques to full and empty generation.
* Generating the FIFO-full status is perhaps the hardest part of a FIFO design. Dual n-bit Gray code counters are valuable to synchronize and n-bit pointer into the opposite clock domain and to use an (n-1)-bit pointer to do “full” comparison.
* Generating the FIFO-empty status is easily accomplished by comparing-equal the n-bit read pointer to the synchronized n-bit write pointer.
* The techniques should work with asynchronous clocks spanning small to large differences in speed.
![image](https://github.com/trista-csee/Asynchronous_FIFO/blob/main/The%20block%20diagram%20for%20FIFO%20style%20%231.png)

* Using n-bit pointers where (n-1) is the number of address bits required to access the entire FIFO memory buffer, the FIFO is empty when both the read and write pointers, including the MSBs are equal. And the FIFO is full when both the read and write pointers, except the MSBs are equal.
* The FIFO design uses n-bit pointers for a FIFO with 2(n-1) write-able locations to help handle full and empty conditions.
* The technique  uses just one set of flip-flops for the Gray code counter.
* A dual n-bit Gray code counter is a Gray code counter that generates both an n-bit Gray code sequence and an (n-1)-bit Gray code sequence.
* The (n-1)-bit Gray code is simply generated by doing an exclusive-or operation on the two MSBs of the n-bit Gray code to generate the MSB for the (n-1)-bit Gray code. This is combined with the (n-2) LSBs of the n-bit Gray code counter to form the (n-1)-bit Gray code counter.
* Synchronization of FIFO pointers into the opposite clock domain is safely accomplished using Gray code pointers.
![image](https://github.com/trista-csee/Asynchronous_FIFO/blob/main/Dual%20n-bit%20Gray%20code%20counter%20block%20diagram%20-%20style%20%231.png)

<!-- Schematic -->
## Schematic
![image]()

* Enlarge the left half
![image]()

* Enlarge the right half
![image]()

<!-- Simulation -->
## Simulation
*  
![image]()

<!-- LICENSE -->
## License
Distributed under the MIT License. See `LICENSE` for more information.

<!-- LET'S GET SOCIAL -->
## Let's Get Social
* [LinkedIn](https://www.linkedin.com/in/hua-chen-wu-363252241/)
* [Github](https://github.com/trista-csee)

<!-- CONTACT -->
## Contact
吳華楨 Trista Wu - trista.cs11@nycu.edu.tw

Project Link: [https://github.com/trista-csee/Asynchronous_FIFO](https://github.com/trista-csee/Asynchronous_FIFO)

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- MARKDOWN LINKS & IMAGES -->
[contributors-shield]: https://img.shields.io/badge/contributors-1-orange.svg?style=flat-square
[license-shield]: https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square
[license-url]: https://choosealicense.com/licenses/mit
[linkedin-shield]: https://img.shields.io/badge/-LinkedIn-black.svg?style=flat-square&logo=linkedin&colorB=555
[linkedin-url]: https://www.linkedin.com/in/hua-chen-wu-363252241/
[product-screenshot]: ./images/projects/portfolio.jpg
